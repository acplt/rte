/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_servicesOPCUAInterface
#define OV_COMPILE_LIBRARY_servicesOPCUAInterface
#endif

#include "servicesOPCUAInterface.h"
#include "libov/ov_macros.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "interface_helpers.h"

OV_DLLFNCEXPORT UA_StatusCode servicesOPCUAInterface_interface_ovServiceInputArgumentsNodeToOPCUA(
		void *context, const UA_NodeId *nodeId, UA_Node** opcuaNode) {
	UA_Node 				*newNode = NULL;
	UA_StatusCode 			result = UA_STATUSCODE_GOOD;
	OV_PATH 				path;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ACCESS				access;
	UA_NodeClass 			nodeClass;
	OV_ELEMENT				element;
	OV_STRING 				tmpString = NULL;
	OV_UINT 				len = 0;
	OV_STRING 				*plist = NULL;
	OV_INSTPTR_servicesOPCUAInterface_interface 	pinterface = Ov_StaticPtrCast(servicesOPCUAInterface_interface, context);


	opcua_helpers_copyUAStringToOV(nodeId->identifier.string, &tmpString);
	plist = ov_string_split(tmpString, "||", &len);
	ov_string_setvalue(&tmpString, NULL);

	UA_NodeId tmpNodeId;
	UA_NodeId_init(&tmpNodeId);
	tmpNodeId.namespaceIndex = nodeId->namespaceIndex;
	tmpNodeId.identifierType = nodeId->identifierType;
	tmpNodeId.identifier.string = UA_String_fromChars(plist[0]);
	ov_string_freelist(plist);

	ov_memstack_lock();
	result = opcua_helpers_resolveNodeIdToPath(tmpNodeId, &path);
	UA_NodeId_deleteMembers(&tmpNodeId);
	if(result != UA_STATUSCODE_GOOD){
		ov_memstack_unlock();
		return result;
	}
	element = path.elements[path.size-1];
	ov_memstack_unlock();
	result = opcua_helpers_getVtblPointerAndCheckAccess(&(element), &pobj, &pVtblObj, &access);
	if(result != UA_STATUSCODE_GOOD){
		return result;
	}

	nodeClass = UA_NODECLASS_VARIABLE;
	newNode = (UA_Node*)UA_calloc(1, sizeof(UA_VariableNode));

	//TODO most code is copied from opcua library --> Move to own function and reuse
	// Basic Attribute
	// BrowseName
	UA_QualifiedName qName;
	qName.name = UA_String_fromChars("InputArguments");
	qName.namespaceIndex = 0; //pinterface->v_interfacenamespace.index;
	newNode->browseName = qName;

	// Description
	OV_STRING tempString = pVtblObj->m_getcomment(pobj, &element);
	UA_LocalizedText lText;
	UA_LocalizedText_init(&lText);
	lText.locale = UA_String_fromChars("en");
	if(tempString){
		lText.text = UA_String_fromChars(tempString);
	} else {
		lText.text = UA_String_fromChars("");
	}
	UA_LocalizedText_copy(&lText,&newNode->description);
	UA_LocalizedText_deleteMembers(&lText);

	// DisplayName
	UA_LocalizedText displayName;
	UA_LocalizedText_init(&displayName);
	displayName.locale = UA_String_fromChars("en");
	displayName.text = UA_String_fromChars("InputArguments");
	UA_LocalizedText_copy(&displayName, &newNode->displayName);
	UA_LocalizedText_deleteMembers(&displayName);

	// NodeId
	UA_NodeId_copy(nodeId, &newNode->nodeId);

	// NodeClass
	newNode->nodeClass 	= nodeClass;

	// WriteMask
	UA_UInt32 writeMask = 0;
	if(element.elemtype != OV_ET_VARIABLE){
		if(access & OV_AC_WRITE){
			writeMask |= (1<<2);	//	BrowseName
			writeMask |= (1<<6);	//	DisplayName
		}
		if(access & OV_AC_RENAMEABLE){
			writeMask |= (1<<14);	//	NodeId
		}
	}
	newNode->writeMask 	= writeMask;

	// value
	OV_UINT sizeInput = countArguments(pobj, TRUE);

	// Variable specific attributes
	// arrayDimensions
	if (sizeInput > 1){
		((UA_VariableNode*)newNode)->arrayDimensionsSize = 1;
		UA_UInt32 *pInputDimension = UA_UInt32_new();
		*pInputDimension = sizeInput;
		((UA_VariableNode*)newNode)->arrayDimensions = pInputDimension;
		// valuerank
		((UA_VariableNode*)newNode)->valueRank = UA_VALUERANK_ONE_DIMENSION;
	}else{
		((UA_VariableNode*)newNode)->arrayDimensionsSize = 0;
		((UA_VariableNode*)newNode)->arrayDimensions = NULL; //UA_Array_new(((UA_VariableNode*)newNode)->arrayDimensionsSize, &UA_TYPES[UA_TYPES_INT32]);
		// valuerank
		((UA_VariableNode*)newNode)->valueRank = UA_VALUERANK_SCALAR;
	}

	// value
	UA_Variant* value = ((UA_Variant*)&((UA_VariableNode*)newNode)->value.data.value.value);
	value->type = &UA_TYPES[UA_TYPES_ARGUMENT];
	value->arrayLength = sizeInput;
	if (sizeInput > 1){
		value->data = UA_Array_new(sizeInput, &UA_TYPES[UA_TYPES_ARGUMENT]);
	}else{
		value->data = UA_Argument_new();
	}

	if (!value->data){
		result = UA_STATUSCODE_BADOUTOFMEMORY;
		return result;
	}
	((UA_VariableNode*)newNode)->value.data.value.hasValue = TRUE;
	((UA_VariableNode*)newNode)->valueSource = UA_VALUESOURCE_DATA;

	OV_ELEMENT tmpPart;
	tmpPart.elemtype = OV_ET_NONE;
	tmpPart.pobj = NULL;
	OV_ELEMENT tmpParrent;
	tmpParrent.pobj = pobj;
	tmpParrent.elemtype = OV_ET_OBJECT;
	OV_UINT count = 0;
	do {
		ov_element_getnextpart(&tmpParrent, &tmpPart, OV_ET_VARIABLE);
		if (tmpPart.elemtype == OV_ET_NONE)
			break;

		if (tmpPart.elemunion.pvar->v_flags == 256){ // InputFlag is set
			UA_Argument_init(&((UA_Argument*)value->data)[count]);
			((UA_Argument*)value->data)[count].description = UA_LOCALIZEDTEXT_ALLOC("en_US","");
			((UA_Argument*)value->data)[count].name = UA_STRING_ALLOC(tmpPart.elemunion.pvar->v_identifier);
			switch(tmpPart.elemunion.pvar->v_vartype){
				case OV_VT_BOOL:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_BOOLEAN].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_INT:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_INT32].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_UINT:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_UINT32].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_SINGLE:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_FLOAT].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_DOUBLE:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_DOUBLE].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_ANY:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_VARIANT].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR_OR_ONE_DIMENSION;
					//((UA_Argument*)value->data)[count].arrayDimensionsSize = ; //TODO get from tmpPart.pvalue
					//((UA_Argument*)value->data)[count].arrayDimensions = UA_UInt32_new();
					//((UA_Argument*)value->data)[count].arrayDimensions[0] = tmpPart.elemunion.pvar->v_veclen;
					break;
				case OV_VT_STRING:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_STRING].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_SCALAR;
					break;
				case OV_VT_BOOL_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_BOOLEAN].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				case OV_VT_INT_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_INT32].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				case OV_VT_UINT_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_UINT32].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				case OV_VT_SINGLE_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_FLOAT].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				case OV_VT_DOUBLE_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_DOUBLE].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				case OV_VT_STRING_VEC:
					((UA_Argument*)value->data)[count].dataType = UA_TYPES[UA_TYPES_STRING].typeId;
					((UA_Argument*)value->data)[count].valueRank = UA_VALUERANK_ONE_DIMENSION;
					break;
				default:
					break;
			}
			if(((UA_Argument*)value->data)[count].valueRank == UA_VALUERANK_SCALAR){
				((UA_Argument*)value->data)[count].arrayDimensionsSize = 0;
				((UA_Argument*)value->data)[count].arrayDimensions = NULL;
			}else if(((UA_Argument*)value->data)[count].valueRank == UA_VALUERANK_ONE_DIMENSION){
				((UA_Argument*)value->data)[count].arrayDimensionsSize = 1;
				((UA_Argument*)value->data)[count].arrayDimensions = UA_UInt32_new();
				((UA_Argument*)value->data)[count].arrayDimensions[0] = tmpPart.elemunion.pvar->v_veclen;
			}
			//TODO fill ((UA_Argument*)value->data)[count].description
			count++;
			if (count == sizeInput){
				break;
			}else{
				continue;
			}
		}
	} while(TRUE);
	ov_string_setvalue(&tmpString, NULL);

	// accessLevel
	UA_Byte accessLevel = 0;
	if(access & OV_AC_READ){
		accessLevel |= (1<<0);
	}
	if(access & OV_AC_WRITE){
		accessLevel |= (1<<1);
	}
	((UA_VariableNode*)newNode)->accessLevel = accessLevel;
	// minimumSamplingInterval
	((UA_VariableNode*)newNode)->minimumSamplingInterval = -1;
	// historizing
	((UA_VariableNode*)newNode)->historizing = UA_FALSE;
	// dataType
	((UA_VariableNode*)newNode)->dataType = UA_NODEID_NUMERIC(0, 0);

	// References have to do manual because it is an virtual node
	// ParentNode
	len = 0;
	plist = NULL;
	tmpString = NULL;
	opcua_helpers_copyUAStringToOV(nodeId->identifier.string, &tmpString);
	plist = ov_string_split(tmpString, "||", &len);
	opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASPROPERTY),
			UA_EXPANDEDNODEID_STRING_ALLOC(pinterface->v_trafo->index, plist[0]), UA_NODECLASS_METHOD,
			UA_FALSE);
	ov_string_freelist(plist);
	ov_string_setvalue(&tmpString, NULL);

	// TypeNode
	opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASTYPEDEFINITION),
			 UA_EXPANDEDNODEID_NUMERIC(0, UA_NS0ID_PROPERTYTYPE), UA_NODECLASS_VARIABLETYPE,
			 UA_TRUE);

	*opcuaNode = newNode;
	return UA_STATUSCODE_GOOD;
}
