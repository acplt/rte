/******************************************************************************
 *
 *   FILE
 *   ----
 *   helpers.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_servicesOPCUAInterface
#define OV_COMPILE_LIBRARY_servicesOPCUAInterface
#endif

#include "servicesOPCUAInterface.h"
#include "libov/ov_macros.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "opcua_ovStore.h"
#include "nodeset_services.h"

OV_UINT countArguments(OV_INSTPTR pobj, OV_BOOL input){
	OV_ELEMENT child;
	child.elemtype = OV_ET_NONE;
	child.pobj = NULL;
	OV_ELEMENT parent;
	parent.pobj = pobj;
	parent.elemtype = OV_ET_OBJECT;
	OV_UINT count = 0;
	int flag = (1L << ((input ? 'i' : 'o')-'a'));
	do {
		ov_element_getnextpart(&parent, &child, OV_ET_VARIABLE);
		if(child.elemtype == OV_ET_NONE)
			break;

		if(child.elemunion.pvar->v_flags & flag) {
			count++;
			continue;
		}
	} while(TRUE);
	return count;
}

OV_DLLFNCEXPORT UA_StatusCode servicesOPCUAInterface_interface_ovServiceNodeToOPCUA(
		void *context, const UA_NodeId *nodeId, UA_Node** opcuaNode) {
	UA_Node 				*newNode = NULL;
	UA_StatusCode 			result = UA_STATUSCODE_GOOD;
	OV_PATH 				path;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ACCESS				access;
	UA_NodeClass 			nodeClass;
	OV_ELEMENT				element;
	OV_INSTPTR_servicesOPCUAInterface_interface 	pinterface = Ov_StaticPtrCast(servicesOPCUAInterface_interface, context);

	ov_memstack_lock();
	result = opcua_helpers_resolveNodeIdToPath(*nodeId, &path);
	if(result != UA_STATUSCODE_GOOD){
		ov_memstack_unlock();
		return result;
	}
	element = path.elements[path.size-1];
	ov_memstack_unlock();
	result = opcua_helpers_getVtblPointerAndCheckAccess(&(element), &pobj, &pVtblObj, &access);
	if(result != UA_STATUSCODE_GOOD){
		return result;
	}

	nodeClass = UA_NODECLASS_METHOD;
	newNode = (UA_Node*)UA_calloc(1, sizeof(UA_MethodNode));

	//TODO most code is copied from opcua library --> Move to own function and reuse
	// Basic Attribute
	// BrowseName
	UA_QualifiedName qName;
	qName.name = UA_String_fromChars(pobj->v_identifier);
	qName.namespaceIndex = nodeId->namespaceIndex;
	newNode->browseName = qName;

	// Description
	OV_STRING tempString = pVtblObj->m_getcomment(pobj, &element);
	UA_LocalizedText lText;
	UA_LocalizedText_init(&lText);
	lText.locale = UA_String_fromChars("en");
	if(tempString){
		lText.text = UA_String_fromChars(tempString);
	} else {
		lText.text = UA_String_fromChars("");
	}
	UA_LocalizedText_copy(&lText,&newNode->description);
	UA_LocalizedText_deleteMembers(&lText);

	// DisplayName
	UA_LocalizedText displayName;
	UA_LocalizedText_init(&displayName);
	displayName.locale = UA_String_fromChars("en");
	displayName.text = UA_String_fromChars(pobj->v_identifier);
	UA_LocalizedText_copy(&displayName, &newNode->displayName);
	UA_LocalizedText_deleteMembers(&displayName);

	// NodeId
	UA_NodeId_copy(nodeId, &newNode->nodeId);

	// NodeClass
	newNode->nodeClass 	= nodeClass;

	// WriteMask
	UA_UInt32 writeMask = 0;
	if(element.elemtype != OV_ET_VARIABLE){
		if(access & OV_AC_WRITE){
			writeMask |= (1<<2);	//	BrowseName
			writeMask |= (1<<6);	//	DisplayName
		}
		if(access & OV_AC_RENAMEABLE){
			writeMask |= (1<<14);	//	NodeId
		}
	}
	newNode->writeMask 	= writeMask;

	((UA_ObjectNode*)newNode)->eventNotifier = 0;

	((UA_MethodNode*)newNode)->executable = TRUE;
	((UA_MethodNode*)newNode)->method = servicesOPCUAInterface_interface_MethodCallback;
	((UA_MethodNode*)newNode)->context = pobj;

	// References
	// HasComponent to parent
	OV_INSTPTR_ov_object pParent = Ov_StaticPtrCast(ov_object, Ov_GetParent(ov_containment, pobj));
	ov_memstack_lock();
	opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
			UA_EXPANDEDNODEID_STRING_ALLOC(opcua_ovStore_searchNamespaceIndex(context, pParent, FALSE),
					ov_path_getcanonicalpath(pParent, 2)), //TODO use checkNodeId function of correct interface instead.
			UA_NODECLASS_OBJECT, UA_FALSE);

	// HasTypeDefinition to Service
	opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASTYPEDEFINITION),
			UA_EXPANDEDNODEID_NUMERIC(pinterface->v_types->index, UA_NSSERVICESID_SERVICESTYPE), UA_NODECLASS_METHOD ,UA_TRUE);
	ov_memstack_unlock();

	//TODO use memstack instead
	// InputArguments
	OV_STRING tmpString = NULL;
	if(countArguments(pobj, TRUE) > 0 ){
		opcua_helpers_copyUAStringToOV(nodeId->identifier.string, &tmpString);
		ov_string_append(&tmpString, "||InputArguments"); //TODO define virtual seperator in opcua
		opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASPROPERTY),
				UA_EXPANDEDNODEID_STRING_ALLOC(pinterface->v_trafo->index, tmpString), UA_NODECLASS_VARIABLE,
				UA_TRUE);
		ov_string_setvalue(&tmpString, NULL);
	}

	// OutputArguments
	tmpString = NULL;
	if(countArguments(pobj, FALSE) > 0 ){
		opcua_helpers_copyUAStringToOV(nodeId->identifier.string, &tmpString);
		ov_string_append(&tmpString, "||OutputArguments");
		opcua_helpers_addReference(newNode, NULL, UA_NODEID_NUMERIC(0, UA_NS0ID_HASPROPERTY),
				UA_EXPANDEDNODEID_STRING_ALLOC(pinterface->v_trafo->index, tmpString), UA_NODECLASS_VARIABLE,
				UA_TRUE);
		ov_string_setvalue(&tmpString, NULL);
	}

	*opcuaNode = newNode;
	return UA_STATUSCODE_GOOD;
}

