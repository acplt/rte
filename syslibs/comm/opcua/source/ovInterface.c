
/******************************************************************************
*
*   FILE
*   ----
*   ovInterface.c
*
*   History
*   -------
*   2019-01-24   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif


#include "opcua.h"
#include "libov/ov_macros.h"
#include "opcua_ovStore.h"
#include "opcua_helpers.h"

OV_DLLFNCEXPORT OV_RESULT opcua_ovInterface_entryPath_set(
    OV_INSTPTR_opcua_ovInterface          pobj,
    const OV_STRING  value
) {
    return opcua_helpers_setRootEntryReference(value, Ov_StaticPtrCast(opcua_interface, pobj), &pobj->v_entryPath);
}

OV_DLLFNCEXPORT OV_RESULT opcua_ovInterface_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_ovInterface pinst = Ov_StaticPtrCast(opcua_ovInterface, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    pinst->v_trafo = Ov_HeapAlloc(OPCUA_InformationModel);
    pinst->v_trafo->dataTypes = NULL;
    pinst->v_trafo->index = 0;
    pinst->v_trafo->uri = UA_String_fromChars(OPCUA_DEFAULT_APPLICATIONURI); //Will be overwritten by config->applicationDescription.applicationUri
    pinst->v_trafo->store = opcua_ovStore_new(pinst);
    pinst->v_trafo->nodeset = NULL;
	//pinst->v_types
    pinst->v_types = NULL;

	//Link generic ov interface interface to server as first association if it is a part
    if(pinst->v_pouterobject != NULL && Ov_CanCastTo(opcua_server, pinst->v_pouterobject)){
    	Ov_LinkPlaced(opcua_serverToInterfaces,
    			Ov_StaticPtrCast(opcua_server,pinst->v_pouterobject),
				Ov_PtrUpCast(opcua_interface, pinst),
				OV_PMH_BEGIN);
    }
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void opcua_ovInterface_destructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_ovInterface pinst = Ov_StaticPtrCast(opcua_ovInterface, pobj);

    /* do what */
    UA_String_deleteMembers(&pinst->v_trafo->uri);
    opcua_ovStore_delete(pinst->v_trafo->store);
    Ov_HeapFree(pinst->v_trafo);
    pinst->v_trafo = NULL;

    /* destroy object */
    ov_object_destructor(pobj);

    return;
}

OV_DLLFNCEXPORT OV_RESULT opcua_ovInterface_load(OV_INSTPTR_opcua_interface pobj, OV_BOOL forceLoad) {
    /*
    *   local variables
    */
    OV_INSTPTR_opcua_ovInterface pinst = Ov_StaticPtrCast(opcua_ovInterface, pobj);
	OV_INSTPTR_opcua_server uaServer = Ov_GetParent(opcua_serverToInterfaces, pobj);
	if(uaServer == NULL){
		return OV_ERR_GENERIC;
	}
	UA_ServerConfig* config = UA_Server_getConfig(uaServer->v_server);
    UA_String_deleteMembers(&pobj->v_trafo->uri);
    UA_String_copy(&config->applicationDescription.applicationUri, &pobj->v_trafo->uri);

    //Use generic load method of uaInterface to load the trafos
	opcua_interface_load(pobj, TRUE);

	//Add reference to OV root for generic interface
	UA_StatusCode retval = UA_STATUSCODE_GOOD;
	retval = UA_Server_addReference(uaServer->v_server, UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER),
			UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES), UA_EXPANDEDNODEID_STRING(pobj->v_trafo->index, pinst->v_entryPath), true);
	if(retval != UA_STATUSCODE_GOOD){
		Ov_Warning(UA_StatusCode_name(retval));
	}
	//Add reference to ov types
	retval = UA_Server_addReference(uaServer->v_server, UA_NODEID_NUMERIC(0, UA_NS0ID_FOLDERTYPE),
			UA_NODEID_NUMERIC(0, UA_NS0ID_HASSUBTYPE), UA_EXPANDEDNODEID_STRING(pobj->v_trafo->index, "/acplt/ov/domain"), true);
	if(retval != UA_STATUSCODE_GOOD){
		Ov_Warning(UA_StatusCode_name(retval));
	}

    return OV_ERR_OK;
}

//TODO add unload function to delete reference
