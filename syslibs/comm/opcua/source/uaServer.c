
/******************************************************************************
*
*   FILE
*   ----
*   uaServer.c
*
*   History
*   -------
*   2019-01-16   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif


#include "opcua.h"
#include "libov/ov_macros.h"

OV_DLLFNCEXPORT OV_RESULT opcua_uaServer_run_set(
    OV_INSTPTR_opcua_uaServer          pobj,
    const OV_BOOL  value
) {
	UA_StatusCode retval = UA_STATUSCODE_GOOD;
	if(value != pobj->v_run){
		if(value){ //start server

			//Create new config
		    UA_ServerConfig* config = UA_ServerConfig_new_default();
			//TODO update config, from uaServerConfig object
		    //TODO insert OV Logger
		    if(!config){
	            ov_string_setvalue(&pobj->v_errorText, "UA_ServerConfig_new_default failed.");
	            pobj->v_error = TRUE;
	            return OV_ERR_GENERIC;
		    }

		    //Create new server
		    UA_Server *server = UA_Server_new(config);
		    if(!server){
		        UA_ServerConfig_delete(config);
	            ov_string_setvalue(&pobj->v_errorText, "UA_Server_new failed.");
	            pobj->v_error = TRUE;
	            return OV_ERR_GENERIC;
		    }

		    //Startup server
			retval = UA_Server_run_startup(server);
			if(retval != UA_STATUSCODE_GOOD){
				UA_Server_delete(server);
			    UA_ServerConfig_delete(config);
				ov_string_print(&pobj->v_errorText, "UA_Server_run_startup failed: %s" , UA_StatusCode_name(retval));
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}

			pobj->v_config = config;
			pobj->v_server = server;
			pobj->v_isRunning = TRUE;

		}else{ //shutdown server
		    if(pobj->v_server != NULL){
		    	retval = UA_Server_run_shutdown(pobj->v_server);
			    UA_Server_delete(pobj->v_server);
			    pobj->v_server = NULL;
		    }
		    if(pobj->v_config != NULL){
		    	UA_ServerConfig_delete(pobj->v_config);
		    	pobj->v_config = NULL;
		    }
			if(retval != UA_STATUSCODE_GOOD){
				ov_string_print(&pobj->v_errorText, "UA_Server_run_shutdown failed: %s" , UA_StatusCode_name(retval));
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC; //TODO check wether return is neccessary?
			}
			pobj->v_isRunning = FALSE;
		}
	    pobj->v_run = value;
	    pobj->v_error = FALSE;
	}
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT opcua_uaServer_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_uaServer pinst = Ov_StaticPtrCast(opcua_uaServer, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = ksbase_ComTask_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    pinst->v_server = NULL;
    pinst->v_config = NULL;

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void opcua_uaServer_destructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_uaServer pinst = Ov_StaticPtrCast(opcua_uaServer, pobj);

    /* do what */
    opcua_uaServer_run_set(pinst, FALSE);

    /* destroy object */
    ksbase_ComTask_destructor(pobj);

    return;
}

OV_DLLFNCEXPORT void opcua_uaServer_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_uaServer pinst = Ov_StaticPtrCast(opcua_uaServer, pobj);

    /* do what */
    opcua_uaServer_run_set(pinst, FALSE);

    /* set the object's state to "shut down" */
    ov_object_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT OV_ACCESS opcua_uaServer_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	switch(pelem->elemtype) {
	case OV_ET_VARIABLE:
		if(pelem->elemunion.pvar->v_offset >= offsetof(OV_INST_ov_object,__classinfo)) {
			if(pelem->elemunion.pvar->v_vartype == OV_VT_CTYPE)
				return OV_AC_NONE;
			else{
				if((pelem->elemunion.pvar->v_varprops & OV_VP_DERIVED)){
					if((pelem->elemunion.pvar->v_varprops & OV_VP_SETACCESSOR)){
						return OV_AC_READWRITE;
					} else {
						return OV_AC_READ;
					}
				} else {
					return OV_AC_READWRITE;
				}
			}
		}
		break;
	default:
		break;
	}

	return ov_object_getaccess(pobj, pelem, pticket);
}

OV_DLLFNCEXPORT void opcua_uaServer_typemethod (
	OV_INSTPTR_ksbase_ComTask	this
) {
    /*    
    *   local variables
    */
	OV_INSTPTR_opcua_uaServer pinst = Ov_StaticPtrCast(opcua_uaServer, this);
	if(pinst->v_run){

		if(pinst->v_server == NULL){
			ov_string_setvalue(&pinst->v_errorText, "Can't UA_Server_run_iterate because server is NULL.");
			pinst->v_error = TRUE;
			return;
		}

		/* timeout is the maximum possible delay (in millisec) until the next
		   _iterate call. Otherwise, the server might miss an internal timeout
		   or cannot react to messages with the promised responsiveness. */
		/* If multicast discovery server is enabled, the timeout does not not consider new input data (requests) on the mDNS socket.
		 * It will be handled on the next call, which may be too late for requesting clients.
		 * if needed, the select with timeout on the multicast socket server->mdnsSocket (see example in mdnsd library)
		 */
//		UA_UInt16 timeout = UA_Server_run_iterate(pinst->v_server, FALSE);
		UA_Server_run_iterate(pinst->v_server, FALSE);
		/* Now we can use the max timeout to do something else. In this case, we
		   just sleep. (select is used as a platform-independent sleep
		   function.)
		struct timeval tv;
		tv.tv_sec = 0;
		tv.tv_usec = timeout * 1000;
		select(0, NULL, NULL, NULL, &tv);
	    */
	}
    return;
}

